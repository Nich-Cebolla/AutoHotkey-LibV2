/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-LibV2/blob/main/RemoveStringsAndComments.ahk
    Author: Nich-Cebolla
    Version: 1.0.0
    License: MIT
*/

; https://github.com/Nich-Cebolla/AutoHotkey-LibV2/blob/main/FillStr.ahk
#include <FillStr>

/**
 * @description - `RemoveStringsAndComments` removes quoted strings and comments from the content.
 * The content is expected to be AHK code,
 *
 * When handling AHK code programmatically, sometimes it is just easier to take the strings and
 * comments out of the code. That's what this function does.
 *
 * A `RemovedItem` object is created for each item that is removed from the text.
 *
 * When text is removed, it is replaced with a string that is equal in length and equal in number
 * of newline characters such that the relative postiion of any discrete text element remains unchanged.
 *
 * The replacement string is generated in one of three ways:
 * - For consecutive quote characters, they are replaced with consecutive replacement characters.
 * If your code happens to use either of the characters chosen for this purpose (`SingleQuoteReplacementChar`
 * and `DoubleQuoteReplacementChar`), just choose any character that does not exist in your code and
 * that is not a significant character to the AHK language and that will work fine.
 * - For most other substrings, the replacement text is
 * `IndexCollection ReplacementChar IndexItem ReplacementChar whitespace...`
 *   - `IndexCollection` : An integer 1-6 representing the type of substring
 *     - 1 "CommentBlock"
 *     - 2 "CommentJsdoc"
 *     - 3 "CommentMultiline"
 *     - 4 "CommentSingleline"
 *     - 5 "Continuation"
 *     - 6 "QuotedString"
 *   - `ReplacementChar` : The function's third parameter
 *   - `IndexItem` : The index position in the array associated with its type.
 *   - whitespace... : A number of space and line feed / carriage return characters to make the
 * length equal to the substring that was removed.
 * - If the length of the above described replacement substring would be longer than the text being
 * removed, a shorter replacement string is generated as `ShortChar IndexShort whitespace...`
 *   - `ShortChar` : A character with code point between `ShortCharStartCode` and `ShortCharEndCode`.
 *   - `IndexShort` : The index position that the object will occupy in the `ShortCollection` object.
 *
 * The `ShortCollection` object is a `Map` object where the keys are the character used as the `ShortChar`
 * and the value is an array of `RemovedItem` objects. The arrays are limited to a length of 99. After
 * filling an array with 99 objects, the code point is incremented by 1 and the content is checked
 * to determine if that character exists within the content. If it does, the code point is incremented
 * again and this repeats until either a character is found that does not exist in the content, or
 * the maximum is reached. If the maximum is reached, an error is thrown.
 *
 * I realize now as I write this documentation that I did not handle cases of lone semicolon comment
 * operators. For every comment operator that is not followed by any text, the position reported
 * by this function will be off by 1-2 characters depending on if the `IndexShort` value is single- or
 * double-digit. If the comment operator has one character after it, then the position reported by this
 * function will be off by 0-1. The offset would only affect characters that occur after the comment
 * operator.
 *
 * Each `RemovedItem` object is associated with a `RegExMatchInfo` object generated by the function.
 * The `RegExMatchInfo` objects have additional subcapture groups which you can use to analyze the
 * content that was removed. The subcapture groups are mapped to `RemovedItem` object properties.
 * @see {@link RemovedItem}.
 *
 * The `RemovedTextResult` object has properties { Continuation, CommentMulti, CommentSingle,
 * CommentBlock, Jsdoc, QuotedString }, each an array of `RemovedItem` objects.
 *
 * If you need to add the substrings back to the content after working with it, call
 * {@link RemovedTextResult#ReplaceAll} or {@link RemovedTextResult#Replace}.
 *
 * If the line ending set to the second parameter `LineEnding` is different from the actual line
 * ending in the content, the position and possibly the line number values reported by this function
 * will be off.
 *
 * @param {String} [Code] - The code to parse.
 * @param {String} [Path] - A path to the file to read then parse. `Path` is ignored if `Code` is set.
 * @param {String} [LineEnding = "`n"] - The line ending character.
 * @param {String} [ReplacementChar = Chr(0xFFFD)] - The character to use as an indicator that a substring
 * is a replacement string generated by this function.
 * @param {String} [SingleQuoteReplacementChar = Chr(0x2000)] - The character to use as a replacement
 * for consecutive single quote characters.
 * @param {String} [DoubleQuoteReplacementChar = Chr(0x2000)] - The character to use as a replacement
 * for consecutive double quote characters.
 * @param {Integer} [ShortCharStartCode] - The initial code point to use for short replacement substrings.
 * @param {Integer} [ShortCharEndCode] - The maximuum code point to use for short replacement substrings.
 * @returns {RemovedTextResult}
 */
class RemoveStringsAndComments {
    static Call(
        Code?
      , Path?
      , LineEnding := '`n'
      , ReplacementChar := Chr(0xFFFD)
      , SingleQuoteReplacementChar := Chr(0x2000)
      , DoubleQuoteReplacementChar := Chr(0x2001)
      , ShortCharStartCode?
      , ShortCharEndCode?
    ) {
        ObjSetBase(Result := {
            Content: RegExReplace(Code ?? FileRead(Path), '\R', LineEnding)
          , CommentBlock: []
          , CommentJsdoc: []
          , CommentMulti: []
          , CommentSingle: []
          , Continuation: []
          , LineEnding: LineEnding
          , ReplacementChar: []
          , SingleQuoteReplacementChar: []
          , DoubleQuoteReplacementChar: []
          , QuotedString: []
        }, RemovedTextResult.Prototype)
        Collections := Result.Collections := [ Result.CommentBlock, Result.CommentJsdoc, Result.CommentMulti, Result.CommentSingle, Result.Continuation, Result.QuotedString ]
        Result.Content := RegExReplace(Result.Content, RemoveStringsAndComments.Pattern.PConsecutiveDouble, DoubleQuoteReplacementChar DoubleQuoteReplacementChar, &DoubleCount)
        Result.Content := RegExReplace(Result.Content, RemoveStringsAndComments.Pattern.PConsecutiveSingle, SingleQuoteReplacementChar SingleQuoteReplacementChar, &SingleCount)
        Result.ConsecutiveDoubleQuotes := DoubleCount
        Result.ConsecutiveSingleQuotes := SingleCount
        Result.ShortCollection := RemoveStringsAndComments.ShortCollection(Result, CharStartCode ?? unset, CharEndCode ?? unset)
        _Process('Continuation')
        _Process('Loop')

        return Result

        _Process(PatternName) {
            Pos := 1
            nl := 1
            Pattern := RemoveStringsAndComments.Pattern.%PatternName%
            loop {
                if !RegExMatch(Result.Content, Pattern, &Match, Pos) {
                    break
                }
                ; Get line count of the segment leading up to the match
                StrReplace(SubStr(Result.Content, Pos, Match.Pos - Pos), LineEnding, , , &linecount)
                ; Calculate line start
                LineStart := nl += linecount
                ; Calculate col start
                ColStart := Match.Pos['text'] - Match.Pos
                ; Get line count of the text that will be removed
                StrReplace(Match['text'], LineEnding, , , &linecount)
                ; Calculate line end
                LineEnd := nl += (linecount || 0)
                ; Calculate col end
                if LineEnd == LineStart {
                    ColEnd := ColStart + Match.Len['text']
                } else {
                    ColEnd := Match.Len['text'] - InStr(Match['text'], LineEnding, , , -1)
                }
                ; Adjust pos
                Pos := Match.Pos['text'] + Match.Len['text']
                ; Determine if it will be a short replacement or a full replacement
                IndexCollection := Result.Index%Match.Mark%
                Collection := Collections[IndexCollection]
                IndexItem := Collection.Length + 1
                Collection.Push(Item := {
                    LineStart: LineStart
                  , ColStart: ColStart
                  , LineEnd: LineEnd
                  , ColEnd: ColEnd
                  , Match: Match
                  , IsShort: false
                  , IndexCollection: IndexCollection
                  , IndexItem: IndexItem
                })
                if StrLen(IndexCollection IndexItem) + 2 <= Match.Len['text'] {
                    Item.Replacement := ReplacementChar IndexCollection ReplacementChar IndexItem
                } else {
                    Item.IndexShort := Result.ShortCollection.Push(Item, &Char)
                    Item.ShortChar := Char
                    Item.Replacement := Item.ShortChar Item.IndexShort
                }
                ObjSetBase(Item, RemovedItem.%Match.Mark%.Prototype)
                Item.SetReplacement(Result)
                Result.Content := StrReplace(Result.Content, Match['text'], Item.Replacement, , , 1)
            }
        }
    }

    class ShortCollection extends Map {
        __New(Result, CharStartCode := 0x2000, CharEndCode := 0xFB04) {
            this.__CharCode := this.__CharStartCode := CharStartCode
            this.__CharEndCode := CharEndCode
            this.__AdjustCharCode(Result)
            this.Set(Chr(this.__CharCode), [])
        }
        Push(Item, &Char) {
            Arr := this.Get(Chr(this.__CharCode))
            if Arr.Length > 98 {
                this.__CharCode++
                this.__AdjustCharCode(Item.Script)
                this.Set(Chr(this.__CharCode), Arr := [])
            }
            Arr.Push(Item)
            Char := Chr(this.__CharCode)
            return Arr.Length
        }
        __AdjustCharCode(Result) {
            while InStr(Result.Content, Chr(this.__CharCode)) {
                this.__CharCode++
                if this.__CharCode > this.__CharEndCode {
                    throw Error('``RemoveStringsAndComments`` ran out of characters used to identify short removed strings.', -1)
                }
            }
        }
    }

    class Pattern {
        static DefineLine := (
            '(?(DEFINE)'
            '(?<NextLine>'
                '(?<IndentNextLine>[ \t]*)'
                '(?:'
                    'class[ \t]+'
                    '(?<class>[a-zA-Z0-9_]+)'
                    '(?:'
                        '[ \t]*extends[ \t]+'
                        '(?<super>[a-zA-Z0-9_.]+)'
                    ')?'
                    '\s*\{'
                '|'
                    '(?<static>static[ \t]+)?'
                    '(?<name>[\w\d_]+)'
                    '(?:'
                        '(?<func>\()'
                    '|'
                        '(?<prop>[^(])'
                    ')'
                    '.*'
                '|'
                    '.*'
                ')'
            '))'
        )
        static IncludeNextLine := '[ \t]*\R(?&NextLine)'
        static CommentBlock := (
            '(?<indent>(?<=[\r\n]|^)[ \t]*)'
            '(*MARK:CommentBlock)'
            '(?<comment>(?<text>'
                ';.*'
                '(?:\R\g{indent};.*)+'
            '))'
            this.IncludeNextLine
        )
        static CommentJsdoc := (
            '(?<indent>(?<=[\r\n]|^)[ \t]*)'
            '(*MARK:CommentJsdoc)'
            '(?<text>'
                '/\*\*'
                '(?<comment>[\w\W]+?)'
                '\*/'
            ')'
            this.IncludeNextLine
        )
        static CommentMulti := (
            '(?<indent>(?<=[\r\n]|^)[ \t]*)'
            '(*MARK:CommentMulti)'
            '(?<text>'
                '/\*\s*'
                '(?<comment>[\w\W]+?)'
                '\R[ \t]*\*/'
            ')'
            this.IncludeNextLine
        )
        static CommentSingle := (
            '(?<indent>(?<=[\r\n]|^)[ \t]*)'
            '(?<lead>[^; \t].*)?'
            '(*MARK:CommentSingle)'
            '(?<text>'
                '(?<=\s|^)'
                ';[ \t]*'
                '(?<comment>.*)'
            ')'
            this.IncludeNextLine
        )
        static Continuation := (
            '(?(DEFINE)(?<singleline>\s*;.*))'
            '(?(DEFINE)(?<multiline>\s*/\*[\w\W]*?\*/))'
            '(?<=[\r\n]).*?'
            '(*MARK:Continuation)'
            '(?<text>'
                '(?<=[\s=:,&(.[?]|^)'
                '(?<quote>[`'"])'
                '(?<comment>'
                    '(?&singleline)'
                '|'
                    '(?&multiline)'
                ')*'
                '\s*+\('
                '(?<body>[\w\W]*?)'
                '\R[ \t]*+\).*?\g{quote}'
            ')'
            '(?<tail>.*)'
        )
        static QuotedString := (
            '(*MARK:QuotedString)'
            '(?<text>'
                '(?<=[\s=:,&(.[?]|^)'
                '([`"`'])'
                '(?<string>.*?)'
                '(?<!``)'
                '(?:````)*'
                '\g{-2}'
            ')'
        )
        static Loop := (
            'SJ)'
            this.DefineLine
            this.QuotedString
            '|' this.CommentBlock
            '|' this.CommentJsdoc
            '|' this.CommentMulti
            '|' this.CommentSingle
        )
        static PConsecutiveDouble := '(?<=^|[\s=([!&%,*])""'
        static PConsecutiveSingle := '(?<=^|[\s=([!&%,*])`'`''
    }

}

class RemovedTextResult {
    static __New() {
        this.DeleteProp('__New')
        Proto := this.Prototype
        Proto.IndexCommentBlock := 1
        Proto.IndexCommentJsdoc := 2
        Proto.IndexCommentMulti := 3
        Proto.IndexCommentSingle := 4
        Proto.IndexContinuation := 5
        Proto.IndexQuotedString := 6
    }

    Replace(Collection) {
        for Item in Collection {
            this.Content := StrReplace(this.Content, Item.Replacement, Item.Text)
        }
    }

    ReplaceAll() {
        for Collection in this.Collections {
            for Item in Collection {
                this.Content := StrReplace(this.Content, Item.Replacement, Item.Text)
            }
        }
    }
}

/**
 * @classdesc - All `RemovedItem` objects have the same properties, many of which pair with
 * subcapture groups on the `RegExMatchInfo` object. If the subcapture group is not present,
 * then the value of the associated property is is an empty string.
 */
class RemovedItem {

    class CommentBlock extends RemovedItemBase.Comment {
    }
    class CommentJsdoc extends RemovedItemBase.Comment {
    }
    class CommentMulti extends RemovedItemBase.Comment {
    }
    class CommentSingle extends RemovedItemBase.Comment {
		/**
		 * The characters following the indentation but before the comment operator (semicolon).
		 * @type {String}
		 * @memberof RemovedItem
		 * @instance
		 */
        Lead => this.Match['lead']
    }
    class Continuation extends RemovedItemBase {
		/**
		 * The text content between the open bracket and the close bracket, i.e. the continuation
         * section's string value before the indentation is removed.
		 * @type {String}
		 * @memberof RemovedItem
		 * @instance
		 */
        Body => this.Match['body']
		/**
		 * The last comment between the open quote character and the open bracket character,
         * if any are present.
		 * @type {String}
		 * @memberof RemovedItem
		 * @instance
		 */
        Comment => this.Match['comment']
		/**
		 * The quote character.
		 * @type {String}
		 * @memberof RemovedItem
		 * @instance
		 */
        Quote => this.Match['quote']
		/**
		 * Any code that is on the same line as the close bracket, after the close quote character.
		 * @type {String}
		 * @memberof RemovedItem
		 * @instance
		 */
        Tail => this.Match['tail']
    }
    class QuotedString extends RemovedItemBase {
		/**
		 * The content of the string without the quote characters.
		 * @type {String}
		 * @memberof RemovedItem
		 * @instance
		 */
        String => this.Match['string']
    }
}

class RemovedItemBase {
    __New(LineStart, ColStart, LineEnd, ColEnd, Match) {
		/**
		 * Column number of the last character of the "text" subcapture group.
		 * @type {String}
		 * @memberof RemovedItem
		 * @instance
		 */
        this.ColEnd := ColEnd
		/**
		 * Column number where the start of the "text" subcapture group begins.
		 * @type {String}
		 * @memberof RemovedItem
		 * @instance
		 */
        this.ColStart := ColStart
    	/**
    	 * Line number where the match terminates.
    	 * @type {String}
    	 * @memberof RemovedItem
    	 * @instance
    	 */
        this.LineEnd := LineEnd
		/**
		 * Line number where the start of the match is located.
		 * @type {String}
		 * @memberof RemovedItem
		 * @instance
		 */
        this.LineStart := LineStart
    	/**
    	 * The `RegExMatchInfo` object.
    	 * @type {String}
    	 * @memberof RemovedItem
    	 * @instance
    	 */
        this.Match := Match
    }

    SetReplacement(Result) {
        Match := this.Match
        over := StrLen(this.Replacement)
        le := Result.LineEnding
        if InStr(Match['text'], le) {
            leLen := StrLen(le)
            for line in StrSplit(Match['text'], le) {
                if over > 0 {
                    this.Replacement .= FillStr[StrLen(line) - over]
                    over -= StrLen(line)
                } else {
                    this.Replacement .= FillStr[StrLen(line)]
                }
                this.Replacement .= le
            }
            this.Replacement := SubStr(this.Replacement, 1, StrLen(this.Replacement) - leLen)
        } else {
            this.Replacement .= FillStr[Match.Len['text'] - over]
        }
    }

	/**
	 * The tabs and/or space characters that occur on the same line as the first character
	 * of the  "text" subcapture group, in-between the previous newline character and the first
	 * non-whitespace character on that line, if any are present.
	 * @type {String}
	 * @memberof RemovedItem
	 * @instance
	 */
    Indent => this.Match['indent']
	/**
	 * The character length of the "text" subcapture group.
	 * @type {String}
	 * @memberof RemovedItem
	 * @instance
	 */
    Len => this.Match.Len['text']
	/**
	 * The character length of the "Indent" subcapture group.
	 * @type {String}
	 * @memberof RemovedItem
	 * @instance
	 */
    LenIndent => this.Match.Len['indent']
	/**
	 * The character position of the last character of the "text" subcapture group.
	 * @type {String}
	 * @memberof RemovedItem
	 * @instance
	 */
    PosEnd => this.PosStart + this.Len
	/**
	 * The character position of the first character of the "text" subcapture group.
	 * @type {String}
	 * @memberof RemovedItem
	 * @instance
	 */
    PosStart => this.Match.Pos['text']
	/**
	 * The string content of the "text" subcapture group.
	 * @type {String}
	 * @memberof RemovedItem
	 * @instance
	 */
    Text => this.Match['text']
	/**
	 * One of the following:
     *   - "CommentBlock"
     *   - "CommentJsdoc"
     *   - "CommentMultiline"
     *   - "CommentSingleline"
     *   - "Continuation"
     *   - "QuotedString"
	 * @type {String}
	 * @memberof RemovedItem
	 * @instance
	 */
    Type => this.Match.Mark

    Body => ''
    Class => ''
    Comment => ''
    Func => ''
    IndentNextLine => ''
    IndexShort => ''
    Lead => ''
    Name => ''
    NextLine => ''
    Prop => ''
    Quote => ''
    ShortChar => ''
    Static => ''
    String => ''
    Super => ''
    Tail => ''

    /**
     * @classdesc - The base for the comment objects `CommentMulti`, `CommentSingle`, `CommentJsdoc`
     * `CommentBlock`.
     */
    class Comment extends RemovedItemBase {
    	/**
    	 * The class name.
    	 * @type {String}
    	 * @memberof RemovedItem
    	 * @instance
    	 */
        Class => this.Match['class']
    	/**
    	 * The content of the comment.
    	 * @type {String}
    	 * @memberof RemovedItem
    	 * @instance
    	 */
        Comment => this.Match['comment']
    	/**
    	 * If it is a function definition, then this subgroup will contain the open
    	 * parentheses. This is mostly to indicate whether its a function or property.
    	 * @type {String}
    	 * @memberof RemovedItem
    	 * @instance
    	 */
        Func => this.Match['func']
    	/**
    	 * The indentation before the first non-whitespace character on the next line.
    	 * @type {String}
    	 * @memberof RemovedItem
    	 * @instance
    	 */
        IndentNextLine => this.Match['IndentNextLine']
    	/**
    	 * The name of the method, property, or function.
    	 * @type {String}
    	 * @memberof RemovedItem
    	 * @instance
    	 */
        Name => this.Match['name']
    	/**
    	 * The next line following the comment, included so the comment can be paired with
    	 * whatever it is describing.
    	 * @type {String}
    	 * @memberof RemovedItem
    	 * @instance
    	 */
        NextLine => this.Match['NextLine']
    	/**
    	 * If it is a property definition, then this subgroup will contain the first
    	 * character following the property name.
    	 * @type {String}
    	 * @memberof RemovedItem
    	 * @instance
    	 */
        Prop => this.Match['prop']
    	/**
    	 * The `static` keyword, if present.
    	 * @type {String}
    	 * @memberof RemovedItem
    	 * @instance
    	 */
        Static => this.Match['static']
    	/**
    	 * If the class has the `extends` keyword, this subgroup will contain the name of
    	 * the superclass.
    	 * @type {String}
    	 * @memberof RemovedItem
    	 * @instance
    	 */
        Super => this.Match['super']
    }
}
