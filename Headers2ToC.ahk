/*
    Github: https://github.com/Nich-Cebolla/AutoHotkey-LibV2/blob/main/Headers2ToC.ahk
    Author: Nich-Cebolla
    Version: 1.0.0
    License: MIT
*/

class Headers2ToC {
    static __New() {
        this.DeleteProp('__New')
        this.patternMarkdown := 'S)(?<=[\r\n]|^)[ \t]*(#+)(.+)'
        this.patternHtml := 'S)(?<=[\r\n]|^)[ \t]*<h(\d)[^>]*>(.+)(?=</h)'
        this.patternFormatElement := '<([^>]+)>'
        ; 1 - indent
        ; 2 - li style
        ; 3 - id
        ; 4 - a style
        ; 5 - format element
        ; 6 - header text
        ; 7 - close format element
        ; 8 - subheader separator
        ; 9 - subheader format element
        ; 10 - subheader
        ; 11 - subheader close format element
        ; 12 - line ending
        this.liFormat := '{}<li{}><a href="#{}"{}>{}{}{}</a>{}{}{}{}</li>{}'
        ; 1 - indent
        ; 2 - ol type
        ; 3 - ol style
        ; 4 - line ending
        this.olFormat := '{}<ol{}{}>{}'
        this.link := 'https://github.com/Nich-Cebolla/AutoHotkey-LibV2/blob/main/Headers2ToC.ahk'
        this.linkText := '<ul><i><sub>Table of contents generated by <a href="' this.link '">Headers2ToC.ahk</a></i></sub></ul>'
    }
    /**
     * Identifies all of the headers in the input input text then constructs a string
     * with a table of contents for all of the headers.
     *
     * If both `Str` and `Path` are unset, the clipboard's context is used.
     *
     * For `Options.aStlye`, `Options.FormatElement`, `Options.liStyle`, `Options.olStyle`, and
     * `Options.olType`, the array index corresponds with the level in the table of contents at which
     * the value will be applied. This is irrespective of the header level used in the input text.
     * For example, if the lowest header level used is 2, then the first value in the option array is
     * still applied to the first level in the table of contents even though header level 1 is never
     * used.
     *
     * @param {String} [Str] - The input text for which to create a table of contents.
     *
     * @param {String} [Path] - The path to the file containing the input text for which to create
     * a table of contents. If `Str` is set, `Path` is ignored.
     *
     * @param {Object} [Options] - An object containing zero or more options as property : value pairs.
     *
     * @param {String} [Options.AppendToBottom = "`n"] - A string to append to the end of the
     * table of contents.
     *
     * @param {String[]} [Options.aStyle = ""] - An array of strings containing inline style tags
     * to use with the <a> elements.
     *
     * The value(s) should be only the text that occurs between the quotation characters, and should
     * not include the quotation characters themselves, and should include the trailing semicolon.
     *
     * The index of each string value corresponds with the level in the table of contents at which the
     * value will be applied.
     *
     * @param {String} [Options.aStyleAll = ""] - A string containing inline style tags to use with
     * all <a> elements at each level in the table of contents.
     *
     * @param {String} [Encoding = ""] - The file encoding to use when reading `Path`. If `Path`
     * is unset, `Options.Encoding` is ignored. If `Options.Encoding` is an empty string,
     * AutoHotkey's default encoding is used.
     *
     * @param {Integer} [Options.Flags = 55] - These flags define rules for converting the header
     * text to the id tag.
     *
     * These flags are set to global variables. If your code encounters a var unset error when the
     * execution reaches one of the flags' global variables, call {@link Headers2ToC_SetConstants}
     * anywhere before your usage of the global variables.
     *
     * The value can be zero or a combination of the following:
     * - HEADERS2TOC_LOWERCASE : Converts all characters to lower case.
     * - HEADERS2TOC_TRIMHYPHENS : Trims leading and trailing hyphens.
     * - HEADERS2TOC_NOPUNCTUATION : Removes punctuation characters. Specifically: `RegExReplace(id, '[^\p{L}\p{N}\-_ ]+', '')`.
     * - HEADERS2TOC_SINGLEHYPHEN : Condenses consecutive hyphens in the header text to a single hyphen.
     *   This does not condense consecutive hyphens in the id tag string; it only does so for consecutive
     *   hyphens present in the header text. This is the only flag not used in the default.
     * - HEADERS2TOC_REPLACESPACE : Replaces space characters with a hyphen.
     * - HEADERS2TOC_SERIALIZEDUPLICATES : If duplicate id tags are created, they are serialized by
     *   adding a hyphen and an integer to the end of the id tag. For example, if three "example-id"
     *   ids are used, the first id would be "example-id", the second id would be "example-id-1",
     *   and the third would be "example-id-2".
     *
     * The default value of `Options.Flags` is based off Github's markdown rendering. If you are
     * creating a table of contents to use with Github, leave `Options.Flags` the default value.
     *
     * Combine values using bitwise "or" ( | ), e.g. `Options.Flags := HEADERS2TOC_LOWERCASE | HEADERS2TOC_TRIMHYPHENS`.
     *
     * @param {String[]} [Options.FormatElement = ""] - An array of strings containing format
     * elements to use with the inner text of the <a> elements.
     *
     * The value(s) must include the inequality signs ( < > ).
     *
     * Your code can combine multiple elements in one value, e.g. "<b><i>".
     *
     * The index of each string value corresponds with the level in the table of contents at which the
     * value will be applied.
     *
     * @param {String} [Options.FormatElementAll = ""] - A string containing format elements to use
     * with the inner text of the <a> elements.
     *
     * The value must include the inequality signs ( < > ).
     *
     * Your code can combine multiple elements in one value, e.g. "<b><i>".
     *
     * @param {String} [Options.Header = "# Table of contents`n`n"] - The header for the table of
     * contents section. `Options.Header` does not get represented in the table of contents.
     *
     * @param {String} [Options.IndentChar = "`s"] - The indent character to use.
     *
     * @param {Integer} [Options.IndentLen = 2] - The number of `Options.IndentChar` to use for one
     * level of indentation.
     *
     * @param {Integer} [Options.InitialIndent = 0] - The initial indentation level.
     *
     * @param {Boolean} [Options.IsMarkdown = true] - If true, the pattern used to identify
     * headers is:
     *
     * S)(?<=[\r\n]|^)[ \t]*(#+)(.+)
     *
     * and the header level is identified by the length of the first subcapture group.
     *
     * If false, the pattern used to identify headers is:
     *
     * S)(?<=[\r\n]|^)[ \t]*<h(\d)[^>]*>(.+)(?=</h)
     *
     * and the header level is identified by the value of the first subcapture group.
     *
     * @param {Boolean} [Options.LinkToHeaders2ToC = true] - If true, a small line of text
     * is included at the bottom of the table of contents linking to
     * {@link https://github.com/Nich-Cebolla/AutoHotkey-LibV2/blob/main/Headers2ToC.ahk this file}.
     * If false, the text is not included.
     *
     * @param {String[]} [Options.liStyle = ""] - An array of strings containing inline style tags
     * to use with the <li> elements.
     *
     * The value(s) should be only the text that occurs between the quotation characters, and should
     * not include the quotation characters themselves, and should include the trailing semicolon.
     *
     * The index of each string value corresponds with the level in the table of contents at which the
     * value will be applied.
     *
     * @param {String} [Options.liStyleAll = ""] - A string containing inline style tags to use with
     * all <li> elements at each level in the table of contents.
     *
     * @param {String} [Options.LineEnding = "`n"] - The literal string to use as the line ending.
     *
     * @param {Integer} [Options.LineStart = 0] - If `Options.LineStart` is nonzero, {@link Headers2ToC}
     * will only use the text that follows the indicated line; all preceding text is ignored. If
     * `Options.PosStart` is nonzero, `Options.LineStart` is ignored.
     *
     * @param {String[]} [Options.olStyle = ""] - An array of strings containing inline style tags
     * to use with the <ol> elements.
     *
     * The value(s) should be only the text that occurs between the quotation characters, and should
     * not include the quotation characters themselves, and should include the trailing semicolon.
     *
     * The index of each string value corresponds with the level in the table of contents at which the
     * value will be applied.
     *
     * Here are two styles you might use:
     * - list-style-type : An alternative to the HTML attribute "type". If using this style, set
     *   `Options.olType := ""`.
     *   - decimal → 1, 2, 3
     *   - decimal-leading-zero → 01, 02, 03
     *   - lower-alpha → a, b, c
     *   - upper-alpha → A, B, C
     *   - lower-roman → i, ii, iii
     *   - upper-roman → I, II, III
     *   - lower-greek → α, β, γ
     *   - armenian, georgian, etc. (for localized numbering)
     * - list-style-position : Controls whether the number is inside the content box or outside in
     *   the margin.
     *   - inside
     *   - outside
     *
     * @param {String} [Options.olStyleAll = ""] - A string containing inline style tags to use with
     * all <ol> elements at each level in the table of contents.
     *
     * @param {String[]} [Options.olType = [ "I', "A", "1", "i", "a" ]] - An array of strings
     * specifying the value to apply to the "type" HTML attribute.
     *
     * The index of each string value corresponds with the level in the table of contents at which the
     * value will be applied.
     *
     * If you use the "list-style-type" style within `Options.olStyle` for all table of contents levels
     * , set `Options.olType := ""`. You can also selectively specify a value in either option:
     * @example
     * options := {
     *     olStyle: [ "list-style-type: upper-roman;", "list-style-type: upper-alpha;" ]
     *   , olType: [ "", "", "1" ]
     * }
     * @
     *
     * @param {Integer} [Options.PosStart = 0] - If `Options.PosStart` is nonzero, {@link Headers2ToC}
     * will only use the text that follows the position; all preceding text is ignored.
     *
     * @param {String} [Options.SubheaderDelimiter = ""] - A string representing a regex pattern
     * that defines the boundary between header and subheader.
     *
     * When in use, `Options.SubheaderDelimiter` defines the substring that separates the header text
     * from the subheader text.
     *
     * For example, say I have a header "# My header - Subheader detail".
     *
     * By specifying `Options.SubheaderDelimiter := " - ", "My header" and "Subheader detail" are
     * treated separately in the table of contents. "My header" will be placed within the inner
     * text of the <a> element, and "Subheader detail" will be placed within the inner text of the
     * <li> element but outside of the <a> element. The subheader also gets different format elements
     * applied.
     *
     * You should also set `Options.SubheaderSeparator` to define a substring that separates the
     * header and subheader. By default, they will be placed immediately following one another
     * (without space).
     *
     * @param {String[]} [Options.SubheaderFormatElement = ""] - An array of strings containing format
     * elements to use with the inner text of the <li> elements, outside of the <a> elements. See
     * `Options.SubheaderDelimiter` for more info.
     *
     * The value(s) must include the inequality signs ( < > ).
     *
     * Your code can combine multiple elements in one value, e.g. "<b><i>".
     *
     * The index of each string value corresponds with the level in the table of contents at which the
     * value will be applied.
     *
     * If a header does not have a subheader, the elements are not placed.
     *
     * @param {String} [Options.SubheaderFormatElementAll = ""] - A string containing format elements
     * to use with the inner text of the <li> elements, outside of the <a> elements. See
     * `Options.SubheaderDelimiter` for more info.
     *
     * The value must include the inequality signs ( < > ).
     *
     * Your code can combine multiple elements in one value, e.g. "<b><i>".
     *
     * @param {String} [Options.SubheaderSeparator = ""] - A string to separate headers from
     * subheaders. If `Options.SubheaderDelimiter` is an empty string, `Options.SubheaderSeparator`
     * is ignored.
     *
     * @returns {Headers2ToC} - The {@link Headers2ToC} object has the following properties:
     * - {String[]} aStyle : An array of the literal style strings that were used at each level.
     * - {String[]} formatElement : An array of the literal strings that were used as format elements
     *   within the inner text of <a> elements at each level.
     * - {String[]} formatElementClose : An array of the literal strings that were used to close the
     *   format elements at each level.
     * - {RegExMatchInfo[]} headers : An array of `RegExMatchInfo` objects that were obtained
     *   when processing the input text. The patterns used are either {@link Headers2ToC.patternMarkdown}
     *   or {@link Headers2ToC.patternHtml}. Four additional properties are added to the object:
     *   - {String} header : The header from the match.
     *   - {String} id : The string used for the id attribute.
     *   - {Integer} level : The header level associated with that match object.
     *   - {String} subheader : The subheader from the match.
     * - {String[]} liStyle : An array of the literal style strings that were used at each level.
     * - {String[]} olstyle : An array of the literal style strings that were used at each level.
     * - {Object} options : The options that were used.
     * - {String[]} subheaderFormatElement : An array of the literal strings that were used as format
     *   elements surrounding the subheaders at each level.
     * - {String[]} subheaderFormatElementClose : An array of the literal stings that were used to
     *   close the subheader format elements at each level.
     * - {String} toc : The table of contents string value.
     *
     * Get your table of contents from the "toc" property.
     */
    __New(Str?, Path?, Options?) {
        options := this.options := Headers2ToC.Options(Options ?? unset)
        if !IsSet(Str) {
            if IsSet(path) {
                str := FileRead(path, options.encoding || unset)
            } else {
                str := A_Clipboard
            }
        }
        proto := RegExMatchInfo.Prototype
        if proto.HasOwnProp('level') {
            originalLevel := proto.GetOwnPropDesc('level')
        } else {
            originalLevel := ''
        }
        if options.IsMarkdown {
            pattern := Headers2ToC.patternMarkdown
            proto.DefineProp('level', { Get: _GetLevelMarkdown })
        } else {
            pattern := Headers2ToC.patternHtml
            proto.DefineProp('level', { Get: _GetLevelHtml })
        }
        if options.PosStart {
            pos := options.PosStart
        } else {
            pos := 1
            loop options.LineStart {
                if RegExMatch(str, '\R', &match, pos) {
                    pos := match.Pos + match.len
                } else {
                    throw Error('``Options.LineStart`` exceeds the number of lines in the input text.', , Options.LineStart)
                }
            }
        }
        headers := this.headers := []
        subheaders := this.subheaders := []
        headers.Capacity := 128
        maxLevel := 0
        minLevel := 4294967295
        if options.SubheaderDelimiter {
            patternSubheader := '(.*?)' options.SubheaderDelimiter '(.*)'
            while RegExMatch(str, pattern, &match, pos) {
                pos := match.Pos + match.Len
                headers.Push(match)
                if RegExMatch(match[2], patternSubheader, &subMatch) {
                    match.header := subMatch[1]
                    match.subheader := subMatch[2]
                } else {
                    match.header := match[2]
                    match.subheader := ''
                }
                maxLevel := Max(maxLevel, match.level)
                minLevel := Min(minLevel, match.level)
            }
        } else {
            while RegExMatch(str, pattern, &match, pos) {
                pos := match.Pos + match.Len
                headers.Push(match)
                match.header := match[2]
                match.subheader := ''
                maxLevel := Max(maxLevel, match.level)
                minLevel := Min(minLevel, match.level)
            }
        }
        headers.Capacity := headers.Length
        rng := maxLevel - minLevel + 1

        ; olType
        olType := []
        olType.Capacity := rng
        if olTypeOpt := options.olType {
            for s in olTypeOpt {
                olType.Push(' type="' s '"')
            }
            loop rng - olTypeOpt.Length {
                olType.Push('')
            }
        } else {
            loop rng {
                olType.Push('')
            }
        }

        ; styles
        liStyle := this.liStyle := []
        olStyle := this.olStyle := []
        aStyle := this.aStyle := []
        for triple in [
            [ options.liStyle, options.liStyleAll, liStyle ]
          , [ options.olStyle, options.olStyleAll, olStyle ]
          , [ options.aStyle, options.aStyleAll, aStyle ]
        ] {
            arr := triple[3]
            all := triple[2]
            arr.Capacity := rng
            if triple[1] {
                optLen := triple[1].Length
                if all {
                    for s in triple[1] {
                        if s {
                            arr.Push(' style="' s ' ' all '"')
                        } else {
                            arr.Push(' style="' all '"')
                        }
                    }
                    loop rng - optLen {
                        arr.Push(' style="' all '"')
                    }
                } else {
                    for s in triple[1] {
                        if s {
                            arr.Push(' style="' s '"')
                        } else {
                            arr.Push('')
                        }
                    }
                    loop rng - optLen {
                        arr.Push('')
                    }
                }
            } else if all {
                loop rng {
                    arr.Push(' style="' all '"')
                }
            } else {
                loop rng {
                    arr.Push('')
                }
            }
        }

        pattern := Headers2Toc.patternFormatElement
        fe := this.formatElement := []
        feC := this.formatElementClose := []
        subFe := this.subheaderFormatElement := []
        subFeC := this.subheaderFormatElementClose := []
        fe.Capacity := feC.Capacity := rng
        for quad in [
            [ options.FormatElement, options.FormatElementAll, fe, feC ]
          , [ options.SubheaderFormatElement, options.SubheaderFormatElementAll, subfe, subfeC ]
        ] {
            opt := quad[1]
            optAll := quad[2]
            list := quad[3]
            listClose := quad[4]
            if opt {
                if optAll {
                    pos := 1
                    cAll := ''
                    while RegExMatch(optAll, pattern, &match, pos) {
                        pos := match.Pos + match.Len
                        cAll .= '</' match[1] '>'
                    }
                    for s in opt {
                        list.Push(s optAll)
                        c := ''
                        if s {
                            pos := 1
                            while RegExMatch(s, pattern, &match, pos) {
                                pos := match.Pos + match.Len
                                c .= '</' match[1] '>'
                            }
                        }
                        listClose.Push(c cAll)
                    }
                    loop rng - opt.Length {
                        list.Push(optAll)
                        listClose.Push(cAll)
                    }
                } else {
                    for s in opt {
                        list.Push(s)
                        c := ''
                        if s {
                            pos := 1
                            while RegExMatch(s, pattern, &match, pos) {
                                pos := match.Pos + match.Len
                                c .= '</' match[1] '>'
                            }
                        }
                        listClose.Push(c)
                    }
                    loop rng - opt.Length {
                        list.Push('')
                        listClose.Push('')
                    }
                }
            } else if optAll {
                pos := 1
                cAll := ''
                while RegExMatch(optAll, pattern, &match, pos) {
                    pos := match.Pos + match.Len
                    cAll .= '</' match[1] '>'
                }
                loop rng {
                    list.Push(optAll)
                    listClose.Push(cAll)
                }
            } else {
                loop rng {
                    list.Push('')
                    listClose.Push('')
                }
            }
        }

        ind := Headers2ToC_IndentHelper(options.IndentLen, options.IndentChar)
        il := options.InitialIndent
        ind.Expand(maxLevel + il)
        le := options.LineEnding
        liFormat := Headers2ToC.liFormat
        olFormat := Headers2ToC.olFormat
        s := options.Header
        separator := options.SubheaderSeparator
        flags := options.Flags
        if flags & HEADERS2TOC_SERIALIZEDUPLICATES {
            ids := Map()
            ids.Default := 0
        }
        i := k := 0
        --minLevel
        --il
        loop headers.Length {
            match := headers[++i]
            if match.level - minLevel > k {
                loop match.level - minLevel - k {
                    ++k
                    s .= Format(olFormat, ind[k + il], olType[k], olStyle[k], le)
                }
            } else if match.level - minLevel < k {
                loop k - match.level + minLevel {
                    s .= ind[k + il] '</ol>' le
                    --k
                }
            }
            id := Trim(match[2], '`s`t')
            if flags & HEADERS2TOC_LOWERCASE {
                id := StrLower(id)
            }
            if flags & HEADERS2TOC_TRIMHYPHENS {
                id := Trim(id, '-')
            }
            if flags & HEADERS2TOC_NOPUNCTUATION {
                id := RegExReplace(id, '[^\p{L}\p{N}\-_ ]+', '')
            }
            if flags & HEADERS2TOC_SINGLEHYPHEN {
                id := RegExReplace(id, '-+', '-')
            }
            if flags & HEADERS2TOC_REPLACESPACE {
                id := RegExReplace(id, ' +', '-')
            }
            if flags & HEADERS2TOC_SERIALIZEDUPLICATES {
                if ct := ids.Get(id) {
                    ids.Set(id, ct + 1)
                    id .= '-' (ct)
                } else {
                    ids.Set(id, 1)
                }
            }
            if match.subheader {
                s .= Format(
                    liFormat
                    ; 1
                  , ind[k + il + 1]
                    ; 2
                  , liStyle[k]
                    ; 3
                  , id
                    ; 4
                  , aStyle[k]
                    ; 5
                  , fe[k]
                    ; 6
                  , Trim(match.header, '`s`t')
                    ; 7
                  , feC[k]
                    ; 8
                  , separator
                    ; 9
                  , subFe[k]
                    ; 10
                  , match.subheader
                    ; 11
                  , subFeC[k]
                    ; 12
                  , le
                )
            } else {
                s .= Format(
                    liFormat
                    ; 1
                  , ind[k + il + 1]
                    ; 2
                  , liStyle[k]
                    ; 3
                  , id
                    ; 4
                  , aStyle[k]
                    ; 5
                  , fe[k]
                    ; 6
                  , Trim(match.header, '`s`t')
                    ; 7
                  , feC[k]
                    ; 8
                  , ''
                    ; 9
                  , ''
                    ; 10
                  , ''
                    ; 11
                  , ''
                    ; 12
                  , le
                )
            }
            match.DefineProp('id', { Value: id })
        }
        loop k {
            s .= ind[k + il] '</ol>' le
            --k
        }
        this.toc := SubStr(s, 1, -1 * StrLen(le)) (options.LinkToHeaders2ToC ? le Headers2ToC.linkText : '') options.AppendToBottom
        if originalLevel {
            proto.DefineProp('level', originalLevel)
        } else {
            proto.DeleteProp('level')
        }

        return

        _GetLevelHtml(self) {
            self.DefineProp('level', { Value: self[1] })
            return self.level
        }
        _GetLevelMarkdown(self) {
            self.DefineProp('level', { Value: self.Len[1] })
            return self.level
        }
    }

    class Options {
        static __New() {
            this.DeleteProp('__New')
            Headers2ToC_SetConstants()
            this.Default := {
                AppendToBottom: '`n'
              , aStyle: ''
              , aStyleAll: ''
              , Encoding: ''
              , Flags: HEADERS2TOC_LOWERCASE | HEADERS2TOC_NOPUNCTUATION | HEADERS2TOC_REPLACESPACE |
                    HEADERS2TOC_TRIMHYPHENS | HEADERS2TOC_SERIALIZEDUPLICATES
              , FormatElement: ''
              , FormatElementAll: ''
              , Header: '# Table of contents`n`n'
              , IndentChar: '`s'
              , IndentLen: 2
              , InitialIndent: 0
              , IsMarkdown: true
              , LinkToHeaders2ToC: true
              , liStyle: ''
              , liStyleAll: ''
              , LineEnding: '`n'
              , LineStart: 0
              , olStyle: ''
              , olStyleAll: ''
              , olType: [ 'I', 'A', '1', 'i', 'a' ]
              , PosStart: 0
              , SubheaderDelimiter: ''
              , SubheaderFormatElement: ''
              , SubheaderFormatElementAll: ''
              , SubheaderSeparator: ''
            }
        }
        static Call(Options?) {
            if IsSet(Options) {
                o := {}
                d := this.Default
                for prop in d.OwnProps() {
                    o.%prop% := HasProp(Options, prop) ? Options.%prop% : d.%prop%
                }
                return o
            } else {
                return this.Default.Clone()
            }
        }
    }
}

; https://github.com/Nich-Cebolla/AutoHotkey-LibV2/blob/main/IndentHelper.ahk
class Headers2ToC_IndentHelper extends Array {
    static __New() {
        this.DeleteProp('__New')
        proto := this.Prototype
        proto.__IndentLen := ''
        proto.DefineProp('ItemHelper', { Call: Array.Prototype.GetOwnPropDesc('__Item').Get })
    }
    __New(IndentLen, IndentChar := '`s') {
        this.__IndentChar := IndentChar
        this.SetIndentLen(IndentLen)
    }
    Expand(Index) {
        s := this[1]
        loop Index - this.Length {
            this.Push(this[-1] s)
        }
    }
    Initialize() {
        c := this.__IndentChar
        this.Length := 1
        s := ''
        loop this.__IndentLen {
            s .= c
        }
        this[1] := s
        this.Expand(4)
    }
    SetIndentChar(IndentChar) {
        this.__IndentChar := IndentChar
        this.Initialize()
    }
    SetIndentLen(IndentLen) {
        this.__IndentLen := IndentLen
        this.Initialize()
    }

    __Item[Index] {
        Get {
            if Index {
                if Abs(Index) > this.Length {
                    this.Expand(Abs(Index))
                }
                return this.ItemHelper(Index)
            } else {
                return ''
            }
        }
    }
    IndentChar {
        Get => this.__IndentChar
        Set => this.SetIndentChar(Value)
    }
    IndentLen {
        Get => this.__IndentLen
        Set => this.SetIndentLen(Value)
    }
}

Headers2ToC_SetConstants() {
    global
    local n := 1
    HEADERS2TOC_LOWERCASE := n
    HEADERS2TOC_TRIMHYPHENS := n *= 2
    HEADERS2TOC_NOPUNCTUATION := n *= 2
    HEADERS2TOC_SINGLEHYPHEN := n *= 2
    HEADERS2TOC_REPLACESPACE := n *= 2
    HEADERS2TOC_SERIALIZEDUPLICATES := n *= 2
}
